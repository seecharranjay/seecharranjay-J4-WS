### 1
This declaration is not possible because a class can only inherit from one super class, and this is extending Mammal and Carnivore
To fix this you can make another file that extends Carnivore. 

### 2
An interface in java is a specification of methods that must be defined when a class implements the interface.
In an abstract class is where features could be defined and over-written into sub classes. interface Emplyee would hold all the features an employee would have.
For example one of them could be pay. 

### 3
```
public class LinkedList implements Stack, Queue {
  public LinkedList() {/*...*/}
  public void addToFront(int v) {/*...*/}
  public int rmFromFront() {/*...*/}
  public void addToBack(int v) {/*...*/}
  public void rmFromBack() {/*...*/}
  
  //FINISH HERE
  public LinkedList() {
    head = null;
    tail = null;
  }
  public void push(int v) {
    addToFront(v);
  }

  public int pop(){
    return rmFromFront();
  }

  public void enqueue(int v){
    addToBack(v);
  }

  public int dequeue() {
    return rmFromFront;
  }
  
}
```

### 4
replace all ints with T
```
public interface Stack<T> {
    void push(T v); 
    T pop();        
    T peek();       
}

public interface Queue<T> {
    void enqueue(T v); 
    T dequeue();       
    T peek();          
}

public class LinkedList<T> implements Stack<T>, Queue<T> {
  public LinkedList() {/*...*/}
  public void addToFront(int v) {/*...*/}
  public int rmFromFront() {/*...*/}
  public void addToBack(int v) {/*...*/}
  public void rmFromBack() {/*...*/}
  
  //FINISH HERE
  public LinkedList() {
    head = null;
    tail = null;
  }
  public void push(T v) {
    addToFront(v);
  }

  public T pop(){
    return rmFromFront();
  }

  public void enqueue(T v){
    addToBack(v);
  }

  public T dequeue() {
    return rmFromFront;
  }
  
}
```
It's now generic because it work with nay object type.

### 5.
```
import java.util.HashMap;

public class TestHashMap {

    public static void main (String[] argv) {
        // Create a new hashmap.
        HashMap<String, String> fabFour = new HashMap();

        // Insert four key and value pairs.
        fabFour.put("John", "John Lennon");
        fabFour.put("Paul", "Paul McCartney");
        fabFour.put("George", "George Harrison");
        fabFour.put("Ringo", "Ringo Star");

        // Use a key to retrieve a value.
        String fullName = fabFour.get("Ringo");

        // Prints "Ringo Star"
        System.out.println(fullName);
    }
}
```

### 6. 
Erasure is when the generic type annotation is erased and replaced with Object with appropriate casting
```
 public static void main(final String args[]) {
        Shelf favorite_words = shelfBuilder();
        favorite_words.addItem("Zoetrope");
        favorite_words.addItem("Succinct");
        //...        
        String s = (String) favorite_words.getItem(1);
        System.out.println(s);
    }
```

### 7. 
```
public class TestShelf {
    public static void main(final String args[]) {

        // TODO: Create a shelf to store Shakespeare character names:
        //       Hamlet, Othello, Cordelia, and Juliet
        Shelf<String> shakespeareCharacters = new Shelf<>("Shakespeare Characters");
        shakespeareCharacters.addItem("Hamlet");
        shakespeareCharacters.addItem("Othello");
        shakespeareCharacters.addItem("Cordelia");
        shakespeareCharacters.addItem("Juliet");

        // TODO: Then print the shelf.
        shakespeareCharacters.printShelf();


        // TODO: Create a shelf to store famous integers:
        //       13, 23, 42, 1729,
        famousIntegers.addItem(13);
        famousIntegers.addItem(23);
        famousIntegers.addItem(42);
        famousIntegers.addItem(1729);

        // TODO: Then print the shelf.
        famousIntegers.printShelf();
    }
}
```

### 8. 
MARK is inefficient because it makes the run time greater. The loop itself takes takes O(100000) so adding the get(i) method makes it O(n^2).

### 9.
It makes the time complexity O(n) becuase it directly traverese through the nodes without the get(i)

### 10.
Because a subclass would only be able to extend one superclass, which limits its ability to inherit behavior from other classes. So it's better the Comparable is an interface.

### 11.
```
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Car implements Comparable<Car> {
    public static void main(String[] args) {
        List<Car> carsList = new ArrayList<>();
        carsList.add(new Car("Porsche", 202));
        carsList.add(new Car("Jeep", 110));
        carsList.add(new Car("Mustang", 144));
        carsList.add(new Car("Lamborghini", 225));

        Collections.sort(carsList);
        for(Car car : carsList) {
            System.out.println("Name: " + car.getName() + " Top Speed: " + car.getTopSpeed());
        }
    }
    private String name;
    private Integer topSpeed;

    public Car(String name, Integer topSpeed) {
        this.name = name;
        this.topSpeed = topSpeed;
    }

    public String getName() {
        return name;
    }

    public Integer getTopSpeed() {
        return topSpeed;
    }

    // TODO: Complete the Car class by adding the compareTo method
    //       needed to correctly implement Comparable<Car>.
    public int compareTo(Car other) {
        return other.topSpeed.compareTo(this.topSpeed); // Descending order
    }

        public static void main(String[] args) {
        List<Car> carsList = new ArrayList<>()

        Collections.sort(carsList)
        for (int i = 0; i < carsList.size(); i++) {
            Car car = carsList.get(i)
            System.out.println("Name " + car.getName() + " Top Speed " + car.getTopSpeed())
        }
}
```



























